Report for Lab4
计34 茹逸中 2013011375

**练习1：**

实现过程：

在load_icode中需要设置trapframe的各属性值。
先设置权限级，将各权限级均设置为用户级。
再设置栈顶地址，设置为用户栈的起始地址。
然后设置指令指针，指向将要执行程序的起始地址。
最后设置eflags，设置为允许中断。

思考题：

用户态进程执行经过了以下过程：
1. 为该进程创建新的内存段
2. 为该进程创建新的页目录表
3. 拷贝数据段和代码段，并进行重定位。
4. 创建用户栈
5. 设置当前进程的页目录表寄存器等
6. 设置中断帧，其中包括代码的起始地址
7. 跳转到起始地址运行

**练习2：**

实现过程：

copy_range函数将原进程中的每一页拷贝到新进程的空间中，然后建立物理内存的映射。

思考题：

为了实现COW机制，在fork时，不进行内存块的复制，而是将内存块的指针复制给新的进程。
内存块内部存储一个变量，即该内存块被引用的次数。
当一个进程需要写这个内存块时，如果该内存块的引用数大于1，则抛出一个异常，单独复制一份新的内存块给需要写内存块的进程，然后该内存块引用数-1.

**练习3：**
fork: 创建进程控制块，复制进程内存，然后将进程设为就绪态。
exec: 在CPU调度该进程运行时，为进程创建新的内存段和页目录表，载入ELF格式文件，载入数据段和代码段并进行重定位，然后设置中断帧，跳转到程序的起始地址。
wait: 如果该进程的一个子进程退出了，那么该进程就会回收这个子进程的资源并进入就绪态。否则进入等待态一直等到一个子进程退出。
exit: 进程退出，进入僵尸态。有可能会唤醒正在等待态的父进程。进程退出后执行schedule函数选择新的进程执行。

生命周期：
1. fork wakeup, RUNNABLE -> 2
2. schedule, RUNNING -> 3
3. exec, RUNNING -> 4,5,8
4. trap(timeout), RUNNABLE -> 6
5. wait, SLEEPING -> 7
6. schedule, RUNNING -> 4,5
7. wakeup, RUNNABLE -> 6 
8. exit, ZOMBIE
